<!DOCTYPE html>
<html>
    <head>
        <title>WebGL Mandelbrot</title>
        <script type="text/javascript" src="2dshader.js"></script>
        <script type="text/javascript">
            window.addEventListener("load", () => {
                const canvas = document.querySelector("canvas");
                if (window.devicePixelRatio !== 1) {
                    canvas.style.width = canvas.width + "px";
                    canvas.style.height = canvas.height + "px";
                    canvas.width *= window.devicePixelRatio;
                    canvas.height *= window.devicePixelRatio;
                }

                const gl = canvas.getContext("webgl");

                let originX = -2.0;
                let originY = -2.0;
                let viewWidth = 4.0;

                let juliaMode = false;
                let juliaX = 0;
                let juliaY = 0;

                if(location.hash) {
                    const hashParams = new URLSearchParams(location.hash.slice(1));
                    originX = Number(hashParams.get("originX") ?? originX);
                    originY = Number(hashParams.get("originY") ?? originY);
                    viewWidth = Number(hashParams.get("viewWidth") ?? viewWidth);
                    juliaMode = Boolean(hashParams.get("juliaMode") ?? juliaMode);
                    juliaX = Number(hashParams.get("x") ?? juliaX);
                    juliaY = Number(hashParams.get("y") ?? juliaY);
                }

                let pickMode = false;

                const zoomFactor = 2.0;

                canvas.addEventListener("click", (evt) => {
                    if(pickMode) return;
                    const {x, y} = getRealCoords(evt);
                    const newWidth = viewWidth / zoomFactor;
                    originX = Math.min(Math.max(x - (newWidth / 2.0), originX), originX + viewWidth - newWidth);
                    originY = Math.min(Math.max(y - (newWidth / 2.0), originY), originY + viewWidth - newWidth);
                    viewWidth = newWidth;
                    setHash();
                    draw();
                });

                document.querySelector("button.resetView").addEventListener("click", () => {
                    originX = -2.0;
                    originY = -2.0;
                    viewWidth = 4.0;
                    setHash();
                    draw();
                });

                const juliaBtn = document.querySelector("button.pickJulia");
                if(!juliaMode) {
                    document.querySelector("button.pickJulia").addEventListener("click", () => {
                        pickMode = true;
                        const prev = canvas.style.cursor;
                        canvas.style.cursor = "crosshair";
                        canvas.addEventListener("click", (evt) => {
                            const {x, y} = getRealCoords(evt);
                            pickMode = false;
                            canvas.style.cursor = prev;
                            window.open(`#juliaMode=true&x=${x}&y=${y}`);
                        }, {once: true})
                    });
                }
                else {
                    juliaBtn.hidden = true;
                }

                function setHash() {
                    const hashParams = new URLSearchParams();
                    if(juliaMode) {
                        hashParams.set("juliaMode", juliaMode);
                        hashParams.set("x", juliaX);
                        hashParams.set("y", juliaY);
                    }
                    if(viewWidth !== 4.0){
                        hashParams.set("originX", originX);
                        hashParams.set("originY", originY);
                        hashParams.set("viewWidth", viewWidth);
                    }
                    location.hash = hashParams.toString();
                }

                function getRealCoords(evt) {
                    const rect = canvas.getBoundingClientRect();
                    const x = ((evt.clientX - rect.left) * window.devicePixelRatio / canvas.width) * viewWidth + originX;
                    const y = ((evt.clientY - rect.top) * window.devicePixelRatio / canvas.height) * viewWidth + originY;
                    return {x, y};
                }

                function draw() {
                    const fsSource = `
                        precision highp float;
                        const int iterations = 10000;
                        const float colorBandwidth = 600.0;
                        uniform bool juliaMode;
                        uniform vec2 juliaCoord;
                        uniform vec2 resolution;
                        uniform vec2 origin;
                        uniform highp float viewWidth;
                        uniform sampler2D colorMap;

                        vec4 getColor(int index) {
                            float colorIndex = mod(float(index), colorBandwidth) / colorBandwidth;
                            vec2 uv = vec2(colorIndex, 0.5);
                            return texture2D(colorMap, uv);
                        }

                        void main() {
                            // Calculate relative coordinates (uv)
                            vec2 trans = gl_FragCoord.xy;
                            trans.y = resolution.y - trans.y;
                            vec2 uv = ((trans / resolution) * viewWidth) + origin;

                            vec2 z, c;
                            if(juliaMode) {
                                z = uv;
                                c = juliaCoord;
                            }
                            else {
                                z = vec2(0.0, 0.0);
                                c = uv;
                            }
                            gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
                            for(int i = 0; i < iterations; i++){
                                z = vec2((z.x * z.x) - (z.y * z.y), 2.0 * z.x * z.y) + c;
                                if(length(z) > 2.0){
                                    gl_FragColor = getColor(i);
                                }
                            }
                        }
                    `;

                    draw2DShader(gl, fsSource, (shaderProgram) => {
                        gl.uniform2f(gl.getUniformLocation(shaderProgram, "resolution"), canvas.width, canvas.height);
                        gl.uniform2f(gl.getUniformLocation(shaderProgram, "origin"), originX, originY);
                        gl.uniform1f(gl.getUniformLocation(shaderProgram, "viewWidth"), viewWidth);
                        gl.uniform1i(gl.getUniformLocation(shaderProgram, "juliaMode"), juliaMode);
                        gl.uniform2f(gl.getUniformLocation(shaderProgram, "juliaCoord"), juliaX, juliaY);

                        const gradient = complexGradient(
                            [0xFF, 0x00, 0x00, 0xFF],
                            [0xFF, 0xFF, 0x00, 0xFF],
                            [0x00, 0xFF, 0x00, 0xFF],
                            [0x00, 0xFF, 0xFF, 0xFF],
                            [0x00, 0x00, 0xFF, 0xFF],
                            [0xFF, 0x00, 0xFF, 0xFF],
                            [0xFF, 0x00, 0x00, 0xFF],);

                        const colorData = new Uint8Array(gradient.flat());

                        const colorTexture = gl.createTexture();
                        gl.bindTexture(gl.TEXTURE_2D, colorTexture);
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, colorData.length / 4, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, colorData);
                    });
                }

                draw();
            });

            function linearGradient(start, finish, steps) {
                const diffs = start.map((x, i) => finish[i] - x);
                steps = steps ?? Math.max(...diffs.map(x => Math.abs(x)));
                return [...new Array(steps + 1)].map((_, i, a) => diffs.map((d, j) => start[j] + (i / (a.length - 1)) * d));
            }

            function complexGradient(...stages) {
                const full = [];
                for(let i = 0; i < stages.length - 1; i++) {
                    const cur = linearGradient(stages[i], stages[i+1]);
                    full.push(...(i === 0 ? cur : cur.slice(1)));
                }
                return full;
            }
        </script>
    </head>
    <body>
        <canvas width="1200" height="1200" style="border: 1px solid black; cursor: zoom-in;"></canvas>
        <div class="controls">
            <button class="resetView">Reset Zoom</button>
            <button class="pickJulia">Pick Julia</button>
        </div>
    </body>
</html>