<!DOCTYPE html>
<html>
<head>
  <title>Voronoi Generator</title>
  <script type="text/javascript" src="parallelWorkers.js"></script>
  <script type="text/javascript">//<![CDATA[
    "use strict";

    function initVoronoi(vor) {
      vor.canvas = vor.querySelector("canvas");
      resizeCanvas(vor.canvas);

      vor.canvas.ctx = vor.canvas.getContext("2d");
      vor.canvas.points = [];
      vor.canvas.isDrawn = false;
      vor.canvas.getPoint = getPoint;
      vor.canvas.clearAll = clearAll;
      vor.canvas.drawPoints = drawPoints;
      //vor.canvas.fillAreas = fillAreasBrute;
      //vor.canvas.fillAreas = fillAreasGrid;
      //vor.canvas.fillAreas = fillAreasBruteParallel;
      vor.canvas.fillAreas = fillAreasGridParallel;
      vor.pointCount = vor.querySelector(".pointCount");
      vor.canvas.addEventListener("click", addPoint);
      vor.canvas.addEventListener("dragover", function (evt) {
        evt.preventDefault();
      });
      vor.canvas.addEventListener("drop", dropImage);

      const genPoints = vor.querySelector(".genPoints");
      genPoints.vor = vor;
      genPoints.addEventListener("click", generatePoints);

      const drawBtn = vor.querySelector(".drawBtn");
      drawBtn.vor = vor;
      drawBtn.addEventListener("click", drawDiagram);

      const clearBtn = vor.querySelector(".clear");
      clearBtn.vor = vor;
      clearBtn.addEventListener("click", clearPoints);

      const colorBtn = vor.querySelector(".colorChange");
      colorBtn.vor = vor;
      colorBtn.addEventListener("click", changeColors);

      const downBtn = vor.querySelector(".download");
      downBtn.vor = vor;
      downBtn.addEventListener("click", downloadImage);
    }

    function resizeCanvas(canvas) {
      if (window.devicePixelRatio !== 1) {
        canvas.style.width = canvas.width + "px";
        canvas.style.height = canvas.height + "px";
        canvas.width *= window.devicePixelRatio;
        canvas.height *= window.devicePixelRatio;
      }
    }

    function generatePoints(evt) {
      const vor = this.vor;

      const numPoints = vor.pointCount.valueAsNumber;

      vor.canvas.points = new Array(numPoints);
      for (let i = 0; i < numPoints; i++) {
        vor.canvas.points[i] = vor.canvas.getPoint(Math.floor(Math.random() * vor.canvas.width), Math.floor(Math.random() * vor.canvas.height));
      }

      /*var pointSpacing = 20;
      var isOdd = false;
      for(var y = pointSpacing / 2; y < vor.canvas.height; y += pointSpacing){
        isOdd = !isOdd;
        for(var x = isOdd ? pointSpacing : pointSpacing / 2; x < vor.canvas.width; x += pointSpacing){
          vor.canvas.points.push(new VorPoint(x, y));
        }
      }*/

      vor.canvas.clearAll();
      vor.canvas.drawPoints();

      vor.querySelector(".drawBtn").disabled = false;
      vor.querySelector(".colorChange").disabled = true;
    }

    function clearAll() {
      this.isDrawn = false;
      this.ctx.clearRect(0, 0, this.width, this.height);
      if (this.imageBmp) {
        this.ctx.save();
        this.ctx.globalAlpha = 0.5;
        this.ctx.drawImage(this.imageBmp, 0, 0);
        this.ctx.restore();
      }
    }

    function getPoint(x, y) {
      if (this.image) {
        const i = 4 * (y * this.width + x);
        const color = this.image.data.slice(i, i + 3);
        return new VorPoint(x, y, color);
      }
      else return new VorPoint(x, y);
    }

    function drawPoints(onlyLast) {
      const ctx = this.ctx;
      ctx.fillStyle = "#000000";
      if (onlyLast) {
        const point = this.points[this.points.length - 1];
        ctx.fillRect(point.x - 1, point.y - 1, 3, 3);
      }
      else {
        this.points.forEach(function (point) {
          ctx.fillRect(point.x - 1, point.y - 1, 3, 3);
        });
      }
    }

    function addPoint(evt) {
      const rect = this.getBoundingClientRect();
      const x = evt.clientX - rect.left;
      const y = evt.clientY - rect.top;
      this.points.push(this.getPoint(x * window.devicePixelRatio, y * window.devicePixelRatio));
      this.isDrawn ? this.fillAreas() : this.drawPoints(true);
    }

    function dropImage(evt) {
      let imageFile = null;
      for (const i = 0; i < evt.dataTransfer.files.length; i++) {
        const curFile = evt.dataTransfer.files[i];
        if (curFile.type.startsWith("image")) {
          imageFile = curFile;
          break;
        }
      }

      if (imageFile) {
        evt.preventDefault();
      }
      else return;

      const canv = this;

      createImageBitmap(imageFile).then(function (imgBmp) {
        const hid = document.createElement("canvas");
        hid.width = imgBmp.width;
        hid.height = imgBmp.height;
        hid.ctx = hid.getContext("2d");
        hid.ctx.drawImage(imgBmp, 0, 0);
        const imgData = hid.ctx.getImageData(0, 0, hid.width, hid.height);

        canv.width = hid.width;
        canv.height = hid.height;
        if (window.devicePixelRatio !== 1) {
          this.style.width = (this.width / window.devicePixelRatio) + "px";
          this.style.height = (this.height / window.devicePixelRatio) + "px";
        }
        canv.imageBmp = imgBmp;
        canv.image = imgData;
        canv.points = [];
        canv.clearAll();

        document.getElementById("useAvgLbl").hidden = false;
      });
      //document.getElementById("testImage").src = URL.createObjectURL(imageFile);
    }

    function drawDiagram(evt) {
      this.vor.canvas.fillAreas();
      this.vor.querySelector(".colorChange").disabled = false;
    }

    function clearPoints(evt) {
      this.vor.canvas.points = [];
      this.vor.canvas.clearAll();
      this.vor.querySelector(".drawBtn").disabled = true;
      this.vor.querySelector(".colorChange").disabled = true;
    }

    function changeColors(evt) {
      this.vor.canvas.points.forEach(function (point) { point.colorArray = randomColor(); });
      this.vor.canvas.fillAreas();
    }

    function downloadImage(evt) {
      const data = this.vor.canvas.toBlob(function (blob) {
        const imgUrl = URL.createObjectURL(blob);
        const imgLink = document.querySelector("a.imgLink");
        imgLink.href = imgUrl;
        imgLink.download = "voronoi.png";
        imgLink.click();
      });
    }

    function fillAreasBrute() {
      const startTime = new Date();
      const colorMap = {};
      const useAvg = this.image && document.getElementById("useAvg").checked;
      const imgData = this.ctx.createImageData(this.width, this.height);
      for (let y = 0; y < this.height; y++) {
        for (let x = 0; x < this.width; x++) {
          const closestPoint = findClosestPoint(this.points, x, y);

          if (useAvg) {
            let pxList = colorMap[closestPoint];
            if (!pxList) {
              pxList = [];
              colorMap[closestPoint] = pxList;
            }
            pxList.push({ x: x, y: y });
          }
          else applyColorToImage(imgData, this.width, x, y, closestPoint.colorArray);
        }
      }
      if (useAvg) {
        const cWidth = this.width;
        for (const point in colorMap) {
          const pxList = colorMap[point];
          const colorTotal = [0, 0, 0];
          for (let i = 0; i < pxList.length; i++) {
            const px = pxList[i];
            const idx = 4 * (px.y * this.width + px.x);
            colorTotal[0] += this.image.data[idx];
            colorTotal[1] += this.image.data[idx + 1];
            colorTotal[2] += this.image.data[idx + 2];
          }
          const colorAvg = colorTotal.map(function (d) { return d / pxList.length; });
          pxList.forEach(function (px) { applyColorToImage(imgData, cWidth, px.x, px.y, colorAvg); });
        }
      }
      this.ctx.putImageData(imgData, 0, 0);
      if (!this.image) this.drawPoints();
      this.isDrawn = true;
      const elapsed = (new Date()) - startTime;
      console.log(`${elapsed / 1000}s`);
    }

    function fillAreasGrid() {
      const startTime = new Date();

      const pixelMap = [...Array(this.height)].map((_, y) => [...Array(this.width)].map((_, x) => ({y, x, point: undefined})));

      function fillSquare(y, x, height, width, point) {
        for(let row = y; row < y + height; row++) {
          for(let col = x; col < x + width; col++) {
            pixelMap[row][col].point = point;
          }
        }
      }

      function fillTriangle(a, b, c, point) {
        const ystart = a.y;
        const yend = Math.max(b.y, c.y);
        let xstart, xend;
        if(a.y === b.y) {
          xstart = b.x;
          xend = c.x;
        }
        else {
          xstart = a.x;
          xend = b.x;
        }
        for(let y = ystart; y <= yend; y++) {
          const n = invlerp(ystart, yend, y);
          for(let x = Math.floor(lerp(a.x, xend, n)); x <= lerp(xstart, c.x, n); x++) {
            pixelMap[y][x].point = point;
          }
        }
      }

      function evaluateCorners(y, x, height, width, points) {
        const a = pixelMap[y][x];
        const b = pixelMap[y][x + width - 1];
        const c = pixelMap[y + height - 1][x];
        const d = pixelMap[y + height - 1][x + width - 1];
        [a,b,c,d].forEach(corner => {
          if(!corner.point) {
            corner.point = findClosestPoint(points, corner.x, corner.y);
          }
        });

        if(a.point === b.point && b.point === c.point && c.point === d.point) {
          fillSquare(y, x, height, width, a.point);
        }
        else {
          if(a.point === b.point) {
            if(b.point === c.point) {
              fillTriangle(a, b, c, a.point);
            }
            else {
              fillSquare(a.y, a.x, 1, width, a.point);
            }
            points = points.filter(p => p.y >= a.point.y);
          }
          if(b.point === d.point) {
            if(a.point === b.point) {
              fillTriangle(a, b, d, a.point);
            }
            else {
              fillSquare(b.y, b.x, height, 1, b.point);
            }
            points = points.filter(p => p.x <= b.point.x);
          }
          if(c.point === d.point) {
            if(b.point === c.point) {
              fillTriangle(b, c, d, b.point);
            }
            else {
              fillSquare(c.y, c.x, 1, width, c.point);
            }
            points = points.filter(p => p.y <= c.point.y);
          }
          if(a.point === c.point) {
            if(c.point === d.point) {
              fillTriangle(a, c, d, a.point);
            }
            else {
              fillSquare(a.y, a.x, height, 1, a.point);
            }
            points = points.filter(p => p.x >= a.point.x);
          }
          evaluateCorners(y, x, Math.floor(height / 2) || 1, Math.floor(width / 2) || 1, points);
          evaluateCorners(y, x + Math.floor(width / 2), Math.floor(height / 2) || 1, Math.ceil(width / 2), points);
          evaluateCorners(y + Math.floor(height / 2), x, Math.ceil(height / 2), Math.floor(width / 2) || 1, points);
          evaluateCorners(y + Math.floor(height / 2), x + Math.floor(width / 2), Math.ceil(height / 2), Math.ceil(width / 2), points);
        }
      }

      evaluateCorners(0, 0, this.height, this.width, this.points);

      const imgData = this.ctx.createImageData(this.width, this.height);
      for (let y = 0; y < this.height; y++) {
        for (let x = 0; x < this.width; x++) {
          const closestPoint = pixelMap[y][x].point;
          applyColorToImage(imgData, this.width, x, y, closestPoint?.colorArray ?? [0xFF, 0xFF, 0xFF]);
        }
      }
      this.ctx.putImageData(imgData, 0, 0);
      if (!this.image) this.drawPoints();
      this.isDrawn = true;

      const elapsed = (new Date()) - startTime;
      console.log(`${elapsed / 1000}s`);
    }

    function voronoiPixel(y, x, width, points) {
      return [...findClosestPoint(points, x, y).colorArray, 0xFF];
    }

    const runPixelWorkers = initPixelWorkers(voronoiPixel, [findClosestPoint, sqDistanceTo]);

    async function fillAreasBruteParallel() {
      const startTime = new Date();
      const imgData = await runPixelWorkers(this.width, this.height, {points: this.points});
      this.ctx.putImageData(imgData, 0, 0);
      if (!this.image) this.drawPoints();
      this.isDrawn = true;
      const elapsed = (new Date()) - startTime;
      console.log(`${elapsed / 1000}s`);
    }

    function gridWorker(startY, startX, height, width, points) {
      const pixelMap = [...Array(height)].map((_, y) => [...Array(width)].map((_, x) => ({y, x, point: undefined})));

      function fillSquare(y, x, height, width, point) {
        for(let row = y; row < y + height; row++) {
          for(let col = x; col < x + width; col++) {
            pixelMap[row][col].point = point;
          }
        }
      }

      function evaluateCorners(y, x, height, width, points) {
        const a = pixelMap[y][x];
        const b = pixelMap[y][x + width - 1];
        const c = pixelMap[y + height - 1][x];
        const d = pixelMap[y + height - 1][x + width - 1];
        [a,b,c,d].forEach(corner => {
          if(!corner.point) {
            corner.point = findClosestPoint(points, corner.x + startX, corner.y + startY);
          }
        });

        if(a.point === b.point && b.point === c.point && c.point === d.point) {
          fillSquare(y, x, height, width, a.point);
        }
        else {
          if(a.point === b.point) {
            fillSquare(a.y, a.x, 1, width, a.point);
            points = points.filter(p => p.y >= a.point.y);
          }
          if(b.point === d.point) {
            fillSquare(b.y, b.x, height, 1, b.point);
            points = points.filter(p => p.x <= b.point.x);
          }
          if(c.point === d.point) {
            fillSquare(c.y, c.x, 1, width, c.point);
            points = points.filter(p => p.y <= c.point.y);
          }
          if(a.point === c.point) {
            fillSquare(a.y, a.x, height, 1, a.point);
            points = points.filter(p => p.x >= a.point.x);
          }
          evaluateCorners(y, x, Math.floor(height / 2) || 1, Math.floor(width / 2) || 1, points);
          evaluateCorners(y, x + Math.floor(width / 2), Math.floor(height / 2) || 1, Math.ceil(width / 2), points);
          evaluateCorners(y + Math.floor(height / 2), x, Math.ceil(height / 2), Math.floor(width / 2) || 1, points);
          evaluateCorners(y + Math.floor(height / 2), x + Math.floor(width / 2), Math.ceil(height / 2), Math.ceil(width / 2), points);
        }
      }

      evaluateCorners(0, 0, height, width, points);

      const imgData = new ImageData(width, height);
      for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
          const closestPoint = pixelMap[y][x].point;
          applyColorToImage(imgData, width, x, y, closestPoint?.colorArray ?? [0xFF, 0xFF, 0xFF]);
        }
      }
      return imgData;
    }

    const gridWidth = 4;
    const gridHeight = 4;
    const gridWorkers = initWorkers(gridWorker, [findClosestPoint, sqDistanceTo, applyColorToImage], undefined, gridHeight * gridWidth);

    async function fillAreasGridParallel() {
      const startTime = new Date();

      const imgData = this.ctx.createImageData(this.width, this.height);
      const chunkWidth = this.width / gridWidth;
      const chunkHeight = this.height / gridHeight;
      await Promise.all(gridWorkers.map((worker, i) => {
        const startY = Math.floor(i / gridWidth) * chunkHeight;
        const startX = (i % gridWidth) * chunkWidth;
        return worker.runAsync({startY, startX, height: chunkHeight, width: chunkWidth, points: this.points})
          .then(chunkImg => {
            for(let y = 0; y < chunkHeight; y++) {
              imgData.data.set(chunkImg.data.slice(4 * y * chunkWidth, 4 * (y + 1) * chunkWidth), 4 * ((y + startY) * this.width + startX));
            }
          })
      }));
      this.ctx.putImageData(imgData, 0, 0);

      if (!this.image) this.drawPoints();
      this.isDrawn = true;

      const elapsed = (new Date()) - startTime;
      console.log(`${elapsed / 1000}s`);
    }

    function fillAreasLines() {
      const lineCount = 100000;
      this.clearAll();
      for (let i = 0; i < lineCount; i++) {
        const x = Math.floor(Math.random() * (this.width + 1));
        const y = Math.floor(Math.random() * (this.height + 1));

        const closestPoint = findClosestPoint(this.points, x, y).point;

        this.ctx.strokeStyle = closestPoint.color;
        this.ctx.beginPath();
        this.ctx.moveTo(x, y);
        this.ctx.lineTo(closestPoint.x, closestPoint.y);
        this.ctx.stroke();
      }
      //window.requestAnimationFrame(fillAreasLines.bind(this));
      this.drawPoints();
      this.isDrawn = true;
    }

    function findClosestPoint(points, x, y) {
      let closestPoint = null;
      let closestDist = -1;
      for (let i = 0; i < points.length; i++) {
        const cur = points[i];
        const dist = sqDistanceTo(cur.x, cur.y, x, y);
        if (closestDist === -1 || closestDist > dist) {
          closestPoint = cur;
          closestDist = dist;
        }
      }
      return closestPoint;
    }

    function applyColorToImage(imgData, width, x, y, color) {
      const i = 4 * (y * width + x);
      imgData.data[i] = color[0];
      imgData.data[i + 1] = color[1];
      imgData.data[i + 2] = color[2];
      imgData.data[i + 3] = 255;
    }

    function VorPoint(x, y, color) {
      this.x = x;
      this.y = y;
      this.colorArray = color || randomColor();
      this.color = colorFromArray(this.colorArray);
    }

    VorPoint.prototype = {
      x: 0,
      y: 0,
      color: "",
      colorArray: [],
      toString() { return `${this.x},${this.y}`; }
    };

    function sqDistanceTo(ax, ay, bx, by) {
      const c = ax - bx;
      const d = ay - by;
      return c * c + d * d; // Euclidean
      //return Math.abs(c) + Math.abs(d); // Manhattan
    }

    function distanceTo(ax, ay, bx, by) {
      return Math.sqrt(sqDistanceTo(ax, ay, bx, by));
    }

    function lerp(x, y, a) {return x * (1 - a) + y * a;}
    function clamp(a, min = 0, max = 1) {return Math.min(max, Math.max(min, a));}
    function invlerp(x, y, a) {return clamp((a - x) / (y - x));}
    function range(x1, y1, x2, y2, a) {return lerp(x2, y2, invlerp(x1, y1, a));}

    function randomChannel() {
      return Math.floor(Math.random() * 0x100);
    }

    function randomColor() {
      return [randomChannel(), randomChannel(), randomChannel()];
    }

    function colorFromArray(array) {
      return "rgb(" + array.join(",") + ")";
    }

    window.addEventListener("load", function () {
      document.querySelectorAll(".voronoi").forEach(initVoronoi);
    })
    //]]></script>
</head>

<body>
  <div class="voronoi">
    <canvas width="800" height="600" style="border: 1px solid black;"></canvas>
    <div class="controls">
      <label>Number of points: <input class="pointCount" type="number" pattern="\d*" min="0" value="100"
          required /></label>
      <label id="useAvgLbl" hidden>Use average color: <input type="checkbox" id="useAvg" checked /></label>
      <br />
      <button class="genPoints">Place Points</button>
      <button class="drawBtn" disabled>Draw Diagram</button>
      <button class="clear">Clear</button>
      <button class="colorChange" disabled>Change Colors</button>
      <button class="download">Download Image</button>
      <a class="imgLink" style="display: none">image download</a>
    </div>
    <!--<img id="testImage" />-->
  </div>
</body>
</html>
