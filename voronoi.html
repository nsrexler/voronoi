<!DOCTYPE html>
<html>
<head>
  <title>Voronoi Generator</title>
  <script type="text/javascript" src="parallelWorkers.js"></script>
  <script type="text/javascript">//<![CDATA[
    "use strict";

    window.addEventListener("load", function () {
      document.querySelectorAll(".voronoi").forEach((vor) => {
        const canvas = vor.querySelector("canvas");
        resizeCanvas(canvas);

        const drawBtn = vor.querySelector(".drawBtn");
        const colorBtn = vor.querySelector(".colorChange");

        canvas.ctx = canvas.getContext("2d");
        canvas.points = [];

        //canvas.fillAreas = fillAreasBrute;
        //canvas.fillAreas = fillAreasBruteParallel;
        //canvas.fillAreas = fillAreasGrid;
        canvas.fillAreas = fillAreasGridParallel;

        let _pointsDrawn = false;
        Object.defineProperty(canvas, "pointsDrawn", {
          get(){return _pointsDrawn;},
          set(val){
            drawBtn.disabled = !val;
            _pointsDrawn = val;
          }
        });

        let _isDrawn = false;
        Object.defineProperty(canvas, "isDrawn", {
          get() {return _isDrawn;},
          set(val) {
            colorBtn.disabled = !val;
            _isDrawn = val;
          }
        });

        canvas.getPoint = (x, y) => {
          if (canvas.image) {
            const i = 4 * (y * canvas.width + x);
            const color = canvas.image.data.slice(i, i + 4);
            return new VorPoint(x, y, color);
          }
          else return new VorPoint(x, y);
        };
        canvas.clearAll = () => {
          canvas.isDrawn = false;
          canvas.ctx.clearRect(0, 0, canvas.width, canvas.height);
          if (canvas.imageBmp) {
            canvas.ctx.save();
            canvas.ctx.globalAlpha = 0.5;
            canvas.ctx.drawImage(canvas.imageBmp, 0, 0);
            canvas.ctx.restore();
          }
        };
        canvas.drawPoints = (onlyLast) => {
          const ctx = canvas.ctx;
          ctx.fillStyle = "#000000";
          if (onlyLast) {
            const point = canvas.points[canvas.points.length - 1];
            ctx.fillRect(point.x - 1, point.y - 1, 3, 3);
          }
          else {
            canvas.points.forEach((point) => {
              ctx.fillRect(point.x - 1, point.y - 1, 3, 3);
            });
          }
          canvas.pointsDrawn = true;
        };
        
        canvas.addEventListener("click", (evt) => {
          const rect = canvas.getBoundingClientRect();
          const x = evt.clientX - rect.left;
          const y = evt.clientY - rect.top;
          canvas.points.push(canvas.getPoint(x * window.devicePixelRatio, y * window.devicePixelRatio));
          canvas.isDrawn ? canvas.fillAreas() : canvas.drawPoints(true);
        });
        canvas.addEventListener("dragover", (evt) => {evt.preventDefault();});
        canvas.addEventListener("drop", (evt) => {
          let imageFile = null;
          for (const i = 0; i < evt.dataTransfer.files.length; i++) {
            const curFile = evt.dataTransfer.files[i];
            if (curFile.type.startsWith("image")) {
              imageFile = curFile;
              break;
            }
          }

          if (imageFile) {
            evt.preventDefault();
          }
          else return;

          createImageBitmap(imageFile).then((imgBmp) => {
            const hid = document.createElement("canvas");
            hid.width = imgBmp.width;
            hid.height = imgBmp.height;
            hid.ctx = hid.getContext("2d");
            hid.ctx.drawImage(imgBmp, 0, 0);
            const imgData = hid.ctx.getImageData(0, 0, hid.width, hid.height);

            canvas.width = hid.width;
            canvas.height = hid.height;
            if (window.devicePixelRatio !== 1) {
              canvas.style.width = (canvas.width / window.devicePixelRatio) + "px";
              canvas.style.height = (canvas.height / window.devicePixelRatio) + "px";
            }
            canvas.imageBmp = imgBmp;
            canvas.image = imgData;
            canvas.points = [];
            canvas.clearAll();

            document.getElementById("useAvgLbl").hidden = false;
          });
          //document.getElementById("testImage").src = URL.createObjectURL(imageFile);
        });

        const pointCount = vor.querySelector(".pointCount");
        const genPoints = vor.querySelector(".genPoints");
        genPoints.addEventListener("click", (evt) => {
          const numPoints = pointCount.valueAsNumber;

          canvas.points = new Array(numPoints);
          for (let i = 0; i < numPoints; i++) {
            canvas.points[i] = canvas.getPoint(Math.floor(Math.random() * canvas.width), Math.floor(Math.random() * canvas.height));
          }

          /*var pointSpacing = 20;
          var isOdd = false;
          for(var y = pointSpacing / 2; y < canvas.height; y += pointSpacing){
            isOdd = !isOdd;
            for(var x = isOdd ? pointSpacing : pointSpacing / 2; x < canvas.width; x += pointSpacing){
              canvas.points.push(new VorPoint(x, y));
            }
          }*/

          canvas.clearAll();
          canvas.drawPoints();
        });

        drawBtn.addEventListener("click", (evt) => {
          canvas.fillAreas();
          canvas.isDrawn = true;
        });

        const clearBtn = vor.querySelector(".clear");
        clearBtn.addEventListener("click", (evt) => {
          canvas.points = [];
          canvas.clearAll();
          canvas.pointsDrawn = false;
        });

        
        colorBtn.addEventListener("click", (evt) => {
          canvas.points.forEach((point) => { point.colorArray = randomColor(); });
          canvas.fillAreas();
        });

        const downBtn = vor.querySelector(".download");
        downBtn.addEventListener("click", (evt) => {
          canvas.toBlob((blob) => {
            const imgUrl = URL.createObjectURL(blob);
            const imgLink = document.querySelector("a.imgLink");
            imgLink.href = imgUrl;
            imgLink.download = "voronoi.png";
            imgLink.click();
          });
        });
      });
    })

    function resizeCanvas(canvas) {
      if (window.devicePixelRatio !== 1) {
        canvas.style.width = canvas.width + "px";
        canvas.style.height = canvas.height + "px";
        canvas.width *= window.devicePixelRatio;
        canvas.height *= window.devicePixelRatio;
      }
    }

    function fillAreasBrute() {
      const startTime = new Date();
      const colorMap = {};
      const useAvg = this.image && document.getElementById("useAvg").checked;
      const imgData = this.ctx.createImageData(this.width, this.height);
      let points = this.points;
      for (let y = 0; y < this.height; y++) {
        let minY = y;
        for (let x = 0; x < this.width; x++) {
          const closestPoint = findClosestPoint(points, x, y);
          if(closestPoint.y < minY) {
            minY = closestPoint.y;
          }

          if (useAvg) {
            let pxList = colorMap[closestPoint];
            if (!pxList) {
              pxList = [];
              colorMap[closestPoint] = pxList;
            }
            pxList.push({ x: x, y: y });
          }
          else applyColorToImage(imgData, this.width, x, y, closestPoint.colorArray);
        }
        points = points.filter(p => p.y >= minY);
      }
      if (useAvg) {
        const cWidth = this.width;
        for (const point in colorMap) {
          const pxList = colorMap[point];
          const colorTotal = [0, 0, 0];
          for (let i = 0; i < pxList.length; i++) {
            const px = pxList[i];
            const idx = 4 * (px.y * this.width + px.x);
            colorTotal[0] += this.image.data[idx];
            colorTotal[1] += this.image.data[idx + 1];
            colorTotal[2] += this.image.data[idx + 2];
          }
          const colorAvg = colorTotal.map((d) => d / pxList.length);
          pxList.forEach((px) => { applyColorToImage(imgData, cWidth, px.x, px.y, colorAvg); });
        }
      }
      this.ctx.putImageData(imgData, 0, 0);
      if (!this.image) this.drawPoints();
      const elapsed = (new Date()) - startTime;
      console.log(`${elapsed / 1000}s`);
    }

    function voronoiPixel(y, x, width, points) {
      return findClosestPoint(points, x, y).colorArray;
    }

    const runPixelWorkers = initPixelWorkers(voronoiPixel, [findClosestPoint, sqDistanceTo]);

    async function fillAreasBruteParallel() {
      const startTime = new Date();
      const imgData = await runPixelWorkers(this.width, this.height, {points: this.points});
      this.ctx.putImageData(imgData, 0, 0);
      if (!this.image) this.drawPoints();
      const elapsed = (new Date()) - startTime;
      console.log(`${elapsed / 1000}s`);
    }

    function checkGrid(startY, startX, height, width, outerHeight, outerWidth, points) {
      const pixelMap = Array(height).fill(null).map((_, y) => Array(width).fill(null).map((_, x) => ({y, x, point: undefined})));

      function fillSquare(y, x, height, width, point) {
        for(let row = y; row < y + height; row++) {
          for(let col = x; col < x + width; col++) {
            pixelMap[row][col].point = point;
          }
        }
      }

      function findPoint(a, points) {
        if(!a.point) {
          a.point = findClosestPoint(points, a.x + startX, a.y + startY);
        }
      }

      function checkHorizLine(a, b, points, isMin) {
        let m = a.point.y;
        for(let x = a.x; x <= b.x; x++) {
          const t = pixelMap[a.y][x];
          findPoint(t, points);
          if(isMin ? t.point.y < m : t.point.y > m) {
            m = t.point.y;
          }
        }
        return m;
      }

      function checkVertLine(a, b, points, isMin) {
        let m = a.point.x;
        for(let y = a.y; y <= b.y; y++) {
          const t = pixelMap[y][a.x];
          findPoint(t, points);
          if(isMin ? t.point.x < m : t.point.x > m) {
            m = t.point.x;
          }
        }
        return m;
      }

      function evaluateCorners(y, x, height, width, points) {
        const nw = pixelMap[y][x];
        const ne = pixelMap[y][x + width - 1];
        const sw = pixelMap[y + height - 1][x];
        const se = pixelMap[y + height - 1][x + width - 1];
        [nw,ne,sw,se].forEach(corner => findPoint(corner, points));

        if(nw.point === ne.point && ne.point === sw.point && sw.point === se.point) {
          fillSquare(y, x, height, width, nw.point);
        }
        else {
          if(nw.point === ne.point) {
            fillSquare(nw.y, nw.x, 1, width, nw.point);
            points = points.filter(p => p.y >= nw.point.y);
          } else if(nw.y + startY !== 0) {
            const m = checkHorizLine(nw, ne, points, true);
            points = points.filter(p => p.y >= m);
          }
          if(ne.point === se.point) {
            fillSquare(ne.y, ne.x, height, 1, ne.point);
            points = points.filter(p => p.x <= ne.point.x);
          } else if(ne.x + startX !== outerWidth - 1) {
            const m = checkVertLine(ne, se, points, false);
            points = points.filter(p => p.x <= m);
          }
          if(sw.point === se.point) {
            fillSquare(sw.y, sw.x, 1, width, sw.point);
            points = points.filter(p => p.y <= sw.point.y);
          } else if(sw.y + startY !== outerHeight - 1) {
            const m = checkHorizLine(sw, se, points, false);
            points = points.filter(p => p.y <= m);
          }
          if(nw.point === sw.point) {
            fillSquare(nw.y, nw.x, height, 1, nw.point);
            points = points.filter(p => p.x >= nw.point.x);
          } else if(nw.x + startX !== 0) {
            const m = checkVertLine(nw, sw, points, true);
            points = points.filter(p => p.x >= m);
          }
          const halfWidth = Math.floor(width / 2);
          const halfHeight = Math.floor(height / 2);
          evaluateCorners(y, x, halfHeight || 1, halfWidth || 1, points);
          evaluateCorners(y, x + halfWidth, halfHeight || 1, width - halfWidth, points);
          evaluateCorners(y + halfHeight, x, height - halfHeight, halfWidth || 1, points);
          evaluateCorners(y + halfHeight, x + halfWidth, height - halfHeight, width - halfWidth, points);
        }
      }

      evaluateCorners(0, 0, height, width, points);

      return pixelMap;
    }

    function fillAreasGrid() {
      const startTime = new Date();

      const pixelMap = checkGrid(0, 0, this.height, this.width, this.height, this.width, this.points);

      const imgData = this.ctx.createImageData(this.width, this.height);
      for (let y = 0; y < this.height; y++) {
        for (let x = 0; x < this.width; x++) {
          const closestPoint = pixelMap[y][x].point;
          applyColorToImage(imgData, this.width, x, y, closestPoint?.colorArray ?? [0xFF, 0xFF, 0xFF, 0xFF]);
        }
      }
      this.ctx.putImageData(imgData, 0, 0);
      if (!this.image) this.drawPoints();

      const elapsed = (new Date()) - startTime;
      console.log(`${elapsed / 1000}s`);
    }

    function gridWorker(startY, startX, height, width, outerHeight, outerWidth, points) {
      const pixelMap = checkGrid(startY, startX, height, width, outerHeight, outerWidth, points);

      const imgData = new ImageData(width, height);
      for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
          const closestPoint = pixelMap[y][x].point;
          applyColorToImage(imgData, width, x, y, closestPoint?.colorArray ?? [0xFF, 0xFF, 0xFF, 0xFF]);
        }
      }
      return imgData;
    }

    const gridWidth = 4;
    const gridHeight = 4;
    const gridWorkers = initWorkers(gridWorker, [checkGrid, findClosestPoint, sqDistanceTo, applyColorToImage], undefined, gridHeight * gridWidth);

    async function fillAreasGridParallel() {
      const startTime = new Date();

      const imgData = this.ctx.createImageData(this.width, this.height);
      const chunkWidth = this.width / gridWidth;
      const chunkHeight = this.height / gridHeight;
      await Promise.all(gridWorkers.map((worker, i) => {
        const startY = Math.floor(i / gridWidth) * chunkHeight;
        const startX = (i % gridWidth) * chunkWidth;
        return worker.runAsync({startY, startX, height: chunkHeight, width: chunkWidth, outerHeight: this.height, outerWidth: this.width, points: this.points})
          .then(chunkImg => {
            for(let y = 0; y < chunkHeight; y++) {
              imgData.data.set(chunkImg.data.slice(4 * y * chunkWidth, 4 * (y + 1) * chunkWidth), 4 * ((y + startY) * this.width + startX));
            }
            //this.ctx.putImageData(chunkImg, startX, startY);
          })
      }));
      this.ctx.putImageData(imgData, 0, 0);

      if (!this.image) this.drawPoints();

      const elapsed = (new Date()) - startTime;
      console.log(`${elapsed / 1000}s`);
    }

    function fillAreasLines() {
      const lineCount = 100000;
      this.clearAll();
      for (let i = 0; i < lineCount; i++) {
        const x = Math.floor(Math.random() * (this.width + 1));
        const y = Math.floor(Math.random() * (this.height + 1));

        const closestPoint = findClosestPoint(this.points, x, y).point;

        this.ctx.strokeStyle = closestPoint.color;
        this.ctx.beginPath();
        this.ctx.moveTo(x, y);
        this.ctx.lineTo(closestPoint.x, closestPoint.y);
        this.ctx.stroke();
      }
      //window.requestAnimationFrame(fillAreasLines.bind(this));
      this.drawPoints();
    }

    function findClosestPoint(points, x, y) {
      let closestPoint = null;
      let closestDist = -1;
      for (let i = 0; i < points.length; i++) {
        const cur = points[i];
        const dist = sqDistanceTo(cur.x, cur.y, x, y);
        if (closestDist === -1 || closestDist > dist) {
          closestPoint = cur;
          closestDist = dist;
        }
      }
      return closestPoint;
    }

    function applyColorToImage(imgData, width, x, y, color) {
      imgData.data.set(color, 4 * (y * width + x));
    }

    function VorPoint(x, y, color) {
      this.x = x;
      this.y = y;
      this.colorArray = color || randomColor();
      this.color = colorFromArray(this.colorArray);
    }

    VorPoint.prototype = {
      x: 0,
      y: 0,
      color: "",
      colorArray: [],
      toString() { return `${this.x},${this.y}`; }
    };

    function sqDistanceTo(ax, ay, bx, by) {
      const c = ax - bx;
      const d = ay - by;
      return c * c + d * d; // Euclidean
      //return Math.abs(c) + Math.abs(d); // Manhattan
    }

    function distanceTo(ax, ay, bx, by) {
      return Math.sqrt(sqDistanceTo(ax, ay, bx, by));
    }

    function lerp(x, y, a) {return x * (1 - a) + y * a;}
    function clamp(a, min = 0, max = 1) {return Math.min(max, Math.max(min, a));}
    function invlerp(x, y, a) {return clamp((a - x) / (y - x));}
    function range(x1, y1, x2, y2, a) {return lerp(x2, y2, invlerp(x1, y1, a));}

    function randomChannel() {
      return Math.floor(Math.random() * 0x100);
    }

    function randomColor() {
      return [randomChannel(), randomChannel(), randomChannel(), 0xFF];
    }

    function colorFromArray(array) {
      return `rgb(${array.slice(0, 3).join(",")}, ${0xFF / array[3]})`;
    }
    //]]></script>
</head>

<body>
  <div class="voronoi">
    <canvas width="800" height="600" style="border: 1px solid black;"></canvas>
    <div class="controls">
      <label>Number of points: <input class="pointCount" type="number" pattern="\d*" min="0" value="100"
          required /></label>
      <label id="useAvgLbl" hidden>Use average color: <input type="checkbox" id="useAvg" checked /></label>
      <br />
      <button class="genPoints">Place Points</button>
      <button class="drawBtn" disabled>Draw Diagram</button>
      <button class="clear">Clear</button>
      <button class="colorChange" disabled>Change Colors</button>
      <button class="download">Download Image</button>
      <a class="imgLink" style="display: none">image download</a>
    </div>
    <!--<img id="testImage" />-->
  </div>
</body>
</html>
